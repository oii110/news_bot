## 

## Определение проблемы:
Пользователи сталкиваются с неудобствами при поиске актуальных новостей по
интересующим их темам, так как им приходится вручную проверять множество
источников. Отсутствие персонализированных уведомлений приводит к пропуску важных
обновлений.
Выработка требований:
Пользовательские истории:
Пользовательские сценарии
1. 2. 3. Как пользователь, я хочу подписаться на определенные категории новостей
(например, технологии, бизнес), чтобы получать только релевантные статьи.
o Задача: Использовать команду /add <category> для подписки и получать
подтверждение.
Как пользователь, я хочу просматривать новости по выбранной категории по
запросу, чтобы оставаться в курсе интересующих меня тем.
o Задача: Использовать команду /news <category> для получения до 5
последних статей с заголовком, описанием и ссылкой.
Как пользователь, я хочу периодически получать новости по моим подпискам,
чтобы не проверять их вручную.
o Задача: Автоматически получать новые статьи каждые 5 минут для
подписанных категорий.
• Оценка пользователей: 10 000 активных пользователей в сутки, предполагая
популярность среди студентов и профессионалов, интересующихся новостями.
• Период хранения данных: Новости и подписки пользователей будут храниться 5
лет для поддержки исторического анализа и возможных регуляторных требований.
## Разработка архитеĸтуры и детальное проеĸтирование
1. Подписка на категорию (/add <category>):
o 1 запрос к Telegram API (/sendMessage) для отправки подтверждения.
o 1 запрос к базе данных для сохранения подписки.
2. Запрос новостей (/news <category>):
o 1 запрос к базе данных для проверки подписки (опционально, если есть
валидация).
o 1 запрос к внешнему News API для получения новостей.
o 1+ запросов к Telegram API (/sendMessage) для отправки статей (до 5
сообщений).
3. Просмотр подписок (/mysubs):
o 1 запрос к базе данных для получения списка подписок.
o 1 запрос к Telegram API (/sendMessage) для отправки ответа.
4. Получение справки или старт (/help, /start):
o 1 запрос к Telegram API (/sendMessage) для отправки сообщения.
5. Автоматическое получение новостей (CheckAndSendNews):
o 1 запрос к базе данных для получения всех подписок.
o 1 запрос к News API для каждой категории (например, 2 категории).
o 1+ запросов к Telegram API (/sendMessage) для отправки новостей каждому
пользователю (до 5 сообщений на категорию).
Предположения о поведении пользователей
• Каждый из 10 000 пользователей в среднем:
o Выполняет 1 подписку в день (/add).
o Запрашивает новости 2 раза в день (/news).
o Проверяет подписки 1 раз в день (/mysubs).
o Использует /start или /help 0.5 раза в день.
o Получает автоматические новости 12 раз в день (каждые 5 минут, 12
циклов CheckAndSendNews).
• Каждая команда /news или автоматическая отправка возвращает до 5 статей.
• Средний размер статьи: 1 КБ (JSON с заголовком, описанием, URL).Соотношение
R/W нагрузки
Read (Чтение):
• Telegram API:
o Получение обновлений (/getUpdates или вебхуки): ~10 000 пользователей * 5
команд/день = 50 000 запросов.
o Все эндпоинты Telegram API для получения данных (например, /getMe)
являются Read-операциями.
• News API:
o Запросы к /top-headlines для /news: 10 000 * 2 запроса/день = 20 000
запросов.
o Запросы для CheckAndSendNews: 2 категории * 12 циклов/день = 24
запроса.
• Database (PostgreSQL):
o Чтение подписок для /mysubs: 10 000 запросов/день.
o Чтение всех подписок для CheckAndSendNews: 12 запросов/день.
o Проверка подписки для /news (если есть): 20 000 запросов/день.
Write (Запись):
• Telegram API:
o Отправка сообщений (/sendMessage):
§ Для /add: 10 000 сообщений/день.
§ Для /news: 10 000 * 2 запроса * 5 сообщений = 100 000
сообщений/день.
§ Для /mysubs: 10 000 сообщений/день.
§ Для /start//help: 10 000 * 0.5 = 5 000 сообщений/день.
§ Для CheckAndSendNews: 10 000 пользователей * 2 категории * 5
сообщений * 12 циклов = 1 200 000 сообщений/день.
• Database (PostgreSQL):
o Сохранение подписки (/add): 10 000 записей/день.
o Логирование взаимодействий (если реализовано): ~50 000 записей/день (по
5 команд/пользователь).
• Временные файлы:
o Нет значительных операций записи на диск, так как бот не создает
мультимедиа (в отличие от примера с видеокружками).
Вывод:
• По количеству запросов: Read-запросы (чтение подписок, получение новостей)
составляют ~30% (50 000 Telegram + 20 024 News API + 30 012 DB = 100 036),
Write-запросы (отправка сообщений, сохранение подписок) ~70% (1 415 000
Telegram + 60 000 DB = 1 475 000). Соотношение R/W ~ 1:14.
• По потреблению ресурсов: Write-запросы к Telegram API (/sendMessage) и News
API являются более затратными из-за сетевых задержек и обработки Markdown.
Read-запросы к базе данных легкие благодаря индексам. Соотношение R/W по
ресурсам ~ 1:5, так как отправка сообщений требует больше CPU и сети, чем
чтение данных.
Объемы трафика
Внутренний трафик (между сервисами)
• Telegram API:
o Входящие обновления (/getUpdates): JSON ~1 КБ/обновление. 50 000
обновлений * 1 КБ = 50 МБ/день.
o Исходящие сообщения (/sendMessage): Текст ~500 байт/сообщение. 1 415
000 сообщений * 0.5 КБ = ~708 МБ/день.
• News API:
o Запросы: ~200 байт/запрос. (20 000 + 24) * 0.2 КБ = ~4 МБ/день.
o Ответы: 5 статей * 1 КБ/статья. (20 000 + 24) * 5 КБ = ~100 МБ/день.
• Database:
o Запросы/ответы: ~100 байт/запрос. 90 012 запросов * 0.1 КБ = ~9 МБ/день.
Итого внутренний трафик: ~50 + 708 + 4 + 100 + 9 = 871 МБ/день.
Внешний трафик (между ботом и Telegram)
• Входящий: 50 000 обновлений * 1 КБ = 50 МБ/день.
• Исходящий: 1 415 000 сообщений * 0.5 КБ = 708 МБ/день.
Итого внешний трафик: 50 + 708 = 758 МБ/день.
Объемы дисковой системы
База данных (PostgreSQL)
• Таблицы:
o users: 10 000 пользователей * ~200 байт/запись = ~2 МБ.
o subscriptions: 10 000 подписок * ~100 байт/запись = ~1 МБ/день. За 5 лет: 1
МБ * 365 * 5 = ~1.8 ГБ.
o articles: 100 статей/день * 2 категории * ~1 КБ/статья = 200 КБ/день. За 5 лет:
200 КБ * 365 * 5 = ~365 МБ.
• Индексы: Примерно 50% от данных, ~1 ГБ за 5 лет.
• Логирование (если реализовано): 50 000 взаимодействий/день * 100 байт = 5
МБ/день. За 5 лет: 5 МБ * 365 * 5 = ~9 ГБ.
Итого для БД: ~2 МБ (users) + 1.8 ГБ (subscriptions) + 365 МБ (articles) + 1 ГБ (индексы) +
9 ГБ (логи) = ~12 ГБ за 5 лет.
Временные файлы
• Бот не создает мультимедиа, поэтому временные файлы минимальны.
• Возможны временные JSON-файлы для кэширования ответов News API: ~1
КБ/статья * 200 статей/день = 200 КБ/день.
• При 100 одновременных запросов: 100 * 200 КБ = 20 МБ временного пространства.
• Рекомендуется настроить автоматическую очистку (например, cron job) для
удаления устаревших файлов.
Итого для временных файлов: 20-50 МБ с учетом запаса и возможных сбоев.
Вывод
• Соотношение R/W:
o По количеству запросов: ~1:14 (Write доминирует из-за отправки
сообщений).
o По ресурсам: ~1:5 (Write-запросы более затратны).
• Трафик:
o Внутренний: ~871 МБ/день.
o Внешний: ~758 МБ/день.
• Диск:
o База данных: ~12 ГБ за 5 лет.
o Временные файлы: 20-50 МБ с очисткой.
## Диаграммы С4 model
Уровень 1: System Context Diagram
Эта диаграмма показывает, как система вписывается в окружающий мир.
Элемент Описание
Пользователь
Telegram Система NewsBot Telegram Bot API News API Человек, использующий Telegram для взаимодействия с ботом.
Наш проект. Доставляет персонализированные новости по
категориям.
Внешний сервис, через который Telegram и наш бот обмениваются
сообщениями.
Внешний сервис, источник новостей и метаданных (например,
NewsAPI.org).
Описание взаимодействий:
• Пользователь отправляет команды (/start, /add, /news, /mysubs, /help) через
Telegram.
• Система NewsBot обрабатывает команды, запрашивает новости у News API и
отправляет ответы через Telegram Bot API.
• News API предоставляет статьи по категориям (например, технологии, бизнес).
Уровень 2: Container Diagram
Эта диаграмма показывает высокоуровневое устройство системы — её "контейнеры"
(сервисы).
Контейнер Описание Технология
Telegram Bot
Service
Database
Service
News API
Client
Принимает команды от пользователя,
Go, github.com/skinass/telegram-
оркестрирует взаимодействие сервисов.
bot-api/v5
Хранит подписки пользователей и кэш
новостей. PostgreSQL
Интерфейс для получения новостей от
внешнего News API. Go, HTTP-клиент
Описание взаимодействий:
• Telegram Bot Service:
o Получает команды от Telegram Bot API (через вебхуки или /getUpdates).
o Записывает/читает подписки в Database Service.
o Запрашивает новости у News API Client.
o Отправляет сообщения пользователям через Telegram Bot API.
• Database Service:
o Хранит таблицы users, subscriptions, articles.
o Обслуживает запросы на чтение/запись от Telegram Bot Service.
• News API Client:
o Отправляет HTTP-запросы к внешнему News API (например, /top-headlines).
o Возвращает JSON с новостями в Telegram Bot Service.
Контракты API
• Telegram Bot API:
o POST /bot<token>/sendMessage: Отправка сообщения.
§ Параметры: chat_id, text, parse_mode.
§ Время отклика: <500 мс.
o POST /bot<token>/getUpdates: Получение обновлений.
§ Время отклика: <1 с.
• News API (пример):
o GET /v2/top-headlines: Получение новостей.
§ Параметры: category, apiKey.
§ Время отклика: <2 с.
Нефункциональные требования
• Время отклика: 95% запросов <1 с.
• Доступность: 99.9%.
• Масштабируемость: Поддержка 100 000 пользователей.
## Схема Базы Данных
Обоснование: Индексы на user_id и category обеспечивают быстрый доступ. PostgreSQL
поддерживает высокую нагрузку с репликами.
## Схема масштабирования
Схема масштабирования при росте нагрузки в 10 раз
При 10-кратном росте нагрузки (с 10 000 до 100 000 пользователей в сутки) текущая
архитектура столкнется с ограничениями по производительности и отказоустойчивости.
Вот план масштабирования:
1. База данных: Оптимизация PostgreSQL и репликация
o Проблема: Текущий экземпляр PostgreSQL может стать узким местом при
100 000 пользователей из-за высокой нагрузки на чтение (подписки,
новости) и запись (новые подписки, логи).
o Решение:
§ Настроить реплики PostgreSQL для операций чтения. Основная база
(master) обрабатывает записи, а реплики — запросы на чтение
(например, /mysubs, CheckAndSendNews).
§ Использовать индексы на таблицы subscriptions (user_id, category)
и articles (category, published_at) для ускорения запросов.
§ Применить разделение (sharding) по user_id, если объем данных
превысит возможности одной БД (маловероятно при 12 ГБ за 5 лет).
§ Настроить пулинг соединений (например, PgBouncer) для управления
тысячами одновременных подключений от Telegram Bot Service.
2. Кэширование: Введение Redis
o Проблема: Частые запросы к БД для чтения подписок и кэшированных
новостей создают нагрузку. News API также имеет лимиты запросов
(например, 1000/день для бесплатного плана NewsAPI.org).
o Решение:
3. 4. § Использовать Redis как in-memory кэш для:
§ Подписок пользователей (user_id → список категорий, TTL 1
час).
§ Новостей по категориям (category → список статей, TTL 5
минут, синхронизировано с циклом CheckAndSendNews).
§ Telegram Bot Service сначала проверяет Redis, снижая нагрузку на
PostgreSQL и News API.
§ Пример: Кэширование ответа /news technology сокращает запросы к
News API на 80% при повторных вызовах.
Масштабирование сервисов: Горизонтальное масштабирование и Load Balancer
o Проблема: Один экземпляр Telegram Bot Service не справится с 1 475 000
исходящих сообщений/день (рассчитано ранее) и ~500 000 обновлений от
Telegram API.
o Решение:
§ Запустить несколько экземпляров Telegram Bot Service (например, 5-
10) в Docker-контейнерах.
§ Поставить Load Balancer (например, Nginx или Traefik) перед
экземплярами для равномерного распределения входящих вебхуков
от Telegram API.
§ Каждый экземпляр Telegram Bot Service является stateless, так как
состояние (например, временные данные команд) хранится в Redis, а
подписки — в PostgreSQL.
Обработка автоматической отправки новостей: Асинхронная очередь задач
o Проблема: Метод CheckAndSendNews выполняет массовую отправку
сообщений (до 1 200 000/день) синхронно, что может привести к перегрузке
Telegram Bot Service и превышению лимитов Telegram API (30
сообщений/сек на чат).
o Решение:
§ Использовать очередь задач (например, RabbitMQ или Kafka).
§ Telegram Bot Service в CheckAndSendNews создает задачи
вида {user_id, category, articles} и помещает их в очередь, вместо
немедленной отправки.
§ Worker-сервисы (отдельные экземпляры Go-приложения) забирают
задачи из очереди, форматируют сообщения и отправляют их через
Telegram API с учетом лимитов (например, используя rate limiting).
§ После отправки воркер подтверждает выполнение задачи или
уведомляет о сбое через другую очередь для повторной обработки.
§ Пользователь получает сообщения асинхронно, что снижает пиковую
нагрузку на Telegram Bot Service.
5. Хранение временных файлов: Объектное хранилище
o Проблема: Текущая реализация использует локальный диск для временных
JSON-файлов (кэш News API, ~20-50 МБ). При нескольких экземплярах
Telegram Bot Service файлы не синхронизируются, а сбои могут оставить
"мусор".
o Решение:
§ Использовать объектное хранилище (например, MinIO или Yandex
Object Storage) для хранения временных файлов.
§ Telegram Bot Service загружает JSON-файлы в хранилище с
уникальными ключами (user_id:timestamp).
§ Worker-сервисы скачивают файлы из хранилища при обработке
задач.
§ Настроить автоматическую очистку (lifecycle policy) для удаления
файлов старше 1 часа, минимизируя объем хранилища (~100 МБ
даже при 100 000 пользователей).
6. Мониторинг и отказоустойчивость
o Проблема: При 100 000 пользователей сбои в одном сервисе могут
нарушить работу всей системы.
o Решение:
§ Внедрить мониторинг с Prometheus и Grafana для отслеживания
метрик (задержки Telegram API, использование CPU/RAM, длина
очереди задач).
§ Использовать health checks в Docker для автоматического
перезапуска упавших контейнеров.
§ Настроить алерты (например, через Alertmanager) для уведомлений о
превышении лимитов или сбоях.
Обновленная архитектура после масштабирования
• Telegram Bot Service: Несколько stateless экземпляров за Load Balancer,
взаимодействуют с Redis, PostgreSQL, RabbitMQ.
• PostgreSQL: Master для записи, реплики для чтения, PgBouncer для пулинга.
• Redis: Кэш для подписок и новостей.
• RabbitMQ: Очередь для асинхронной отправки сообщений.
• MinIO: Объектное хранилище для временных файлов.
• Prometheus/Grafana: Мониторинг и алерты.
## Unit-тестирование
Проект включает комплексную систему unit-тестирования для основного сервиса Telegram
Bot Service. Тесты написаны с использованием стандартного пакета testing в Go и
библиотеки Testify для создания моков, обеспечивая высокое покрытие ключевой
функциональности.
Структура тестов
• tgbot/test/internal/usecases/: Unit-тесты для Telegram Bot Service.
o bot_usecase_test.go: Тесты для методов обработки команд, форматирования
новостей и логики автоматической отправки.
o mock_subscription_usecase.go: Моки для
интерфейса SubscriptionUsecaseInterface.
o mock_news_usecase.go: Моки для интерфейса NewsUsecaseInterface.
Основные возможности тестирования
• Telegram Bot Service тесты:
o Моки для объектов Telegram Bot API (tgbotapi.BotAPI, tgbotapi.Message).
o Тестирование обработчиков команд (/start, /add, /news, /mysubs, /help) в
методе HandleCommand.
o Проверка логики обработки неизвестных команд.
o Тестирование метода FormatArticle для корректного форматирования
новостей в Markdown.
o Тестирование метода CheckAndSendNews для сценариев с новыми статьями
и их отсутствием.
o Моки для внешних зависимостей (SubscriptionUsecase, NewsUsecase) с
использованием Testify.
o Проверка краевых случаев (например, пустой список категорий, ошибки
API).
Запуск unit-тестов
# Запуск всех unit-тестов
make unit-test
# Прямо через Docker Compose
docker-compose run bot go test -v ./test/internal/usecases -run TestBotUsecase
# Локальный запуск
go test -v ./test/internal/usecases -run TestBotUsecase
Конфигурация тестов
• Тесты используют стандартные возможности Go без дополнительных
конфигурационных файлов.
• Моки генерируются с помощью Testify, обеспечивая изоляцию от внешних
сервисов (Telegram API, News API, PostgreSQL).
• Тесты выполняются быстро, так как не требуют сетевых вызовов или работы с
реальными файлами.
Пример unit-теста
func TestHandleCommand(t *testing.T) {
mockSubUsecase := &MockSubscriptionUsecase{}
mockNewsUsecase := &MockNewsUsecase{}
bot, _ := tgbotapi.NewBotAPIWithClient("token", "endpoint", &http.Client{})
usecase := NewBotUsecase(bot, mockSubUsecase, mockNewsUsecase,
[]string{"technology"})
update := tgbotapi.Update{
Message: &tgbotapi.Message{
Chat: &tgbotapi.Chat{ID: 123},
Text: "/start",
},
}
usecase.HandleCommand(context.Background(), update)
// Проверяем, что бот отправил правильное сообщение
if len(bot.Messages) == 0 || bot.Messages[0].Text != "Здравствуйте! Данный бот
предназначен для получения новостей..." {
t.Errorf("Expected welcome message, got: %v", bot.Messages)
}
}
## Интеграционное тестирование
Проект включает интеграционные тесты для проверки взаимодействия между Telegram
Bot Service, Telegram API и внешними зависимостями, используя Telegram Dummy Server
(TDS) для эмуляции Telegram API.
Типы интеграционных тестов
• Полный workflow тестирование:
o Тест полного цикла взаимодействия пользователя: подписка на категорию
(/add), запрос новостей (/news), автоматическая отправка новостей
(CheckAndSendNews).
o Проверка взаимодействия Telegram Bot Service с TDS (эмуляция Telegram
API).
o Проверка обработки ошибок (например, неверная категория, сбои News
API).
• Database и News API интеграционные тесты:
o Тестирование реальных запросов к PostgreSQL (в тестовой БД через
Docker).
o Моки для News API для возврата предопределенных статей.
o Валидация отправленных сообщений через TDS.
Особенности интеграционных тестов
• Использование TDS для эмуляции Telegram API, что позволяет проверять
реальную отправку сообщений без сетевых вызовов к Telegram.
• Тесты создают временную тестовую БД в Docker, минимизируя зависимости.
• Моки для SubscriptionUsecase и NewsUsecase позволяют изолировать внешние API.
• Тесты медленнее unit-тестов из-за запуска TDS и Docker, но обеспечивают
проверку реального взаимодействия.
Запуск интеграционных тестов
# Запуск всех интеграционных тестов
make integration-test
# Прямо через Docker Compose
docker-compose run bot go test -v ./test/internal/usecases -run TestBotCommands
# Локальный запуск
go test -v ./test/internal/usecases -run TestBotCommands
Пример интеграционного теста
func TestBotCommands(t *testing.T) {
tds := NewTDS()
ts := httptest.NewServer(tds)
defer ts.Close()
tgbotapi.APIEndpoint = ts.URL + "/bot%s/%s"
bot, _ := tgbotapi.NewBotAPIWithClient("token", tgbotapi.APIEndpoint, &http.Client{})
mockSubUsecase := &MockSubscriptionUsecase{}
mockNewsUsecase := &MockNewsUsecase{}
usecase := NewBotUsecase(bot, mockSubUsecase, mockNewsUsecase,
[]string{"technology"})
mockSubUsecase.On("SaveSubscription", mock.Anything, mock.Anything,
mock.Anything).Return(nil)
err := SendMsgToBot(123, "/add technology")
if err != nil {
t.Fatalf("SendMsgToBot error: %v", err)
}
time.Sleep(50 * time.Millisecond)
tds.Lock()
if len(tds.Answers[123]) == 0 || tds.Answers[123][0] != "Вы успешно подписались на
категорию 'technology'!" {
t.Errorf("Expected subscription confirmation, got: %v", tds.Answers)
}
tds.Unlock()
}
## Сборка
• Dockerfile, docker-compose.yml, Makefile обеспечивают сборку, тестирование и
запуск через:
• make build
• make unit-test
• make integration-test
make run