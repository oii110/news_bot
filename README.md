## News Update Bot
Данный бот использует NewsAPI для отслеживания новостей с большого количества источников (7500+). Он позволяет пользователю выбрать определенную категорию для отслеживания актуальных новостей. После подписки на определенные рассылки, бот будет присылать уведомления при появлении новых статей.

1) Backend: Go
2) DataBase: PostgreSQL
3) API: NewsAPI

# Участники проекта
Грибкова Екатерина 5130904/20102

# Определение проблемы

Пользователи сталкиваются с неудобствами при поиске актуальных новостей по интересующим их темам, так как им приходится вручную проверять множество источников. Отсутствие персонализированных уведомлений приводит к пропуску важных обновлений.

## Выработка требований

### Пользовательские истории
1. **Как пользователь, я хочу подписаться на определенные категории новостей (например, технологии, бизнес), чтобы получать только релевантные статьи.**
   - Задача: Использовать команду `/add <category>` для подписки и получать подтверждение.
2. **Как пользователь, я хочу просматривать новости по выбранной категории по запросу, чтобы оставаться в курсе интересующих меня тем.**
   - Задача: Использовать команду `/news <category>` для получения до 5 последних статей с заголовком, описанием и ссылкой.
3. **Как пользователь, я хочу периодически получать новости по моим подпискам, чтобы не проверять их вручную.**
   - Задача: Автоматически получать новые статьи каждые 5 минут для подписанных категорий.

### Оценка пользователей
- 10 000 активных пользователей в сутки, предполагая популярность среди студентов и профессионалов, интересующихся новостями.
- Период хранения данных: Новости и подписки пользователей будут храниться 5 лет для поддержки исторического анализа и возможных регуляторных требований.

## Разработка архитектуры и детальное проектирование

### Подписка на категорию (`/add <category>`)
- 1 запрос к Telegram API (`/sendMessage`) для отправки подтверждения.
- 1 запрос к базе данных для сохранения подписки.

### Запрос новостей (`/news <category>`)
- 1 запрос к базе данных для проверки подписки (опционально, если есть валидация).
- 1 запрос к внешнему News API для получения новостей.
- 1+ запросов к Telegram API (`/sendMessage`) для отправки статей (до 5 сообщений).

### Просмотр подписок (`/mysubs`)
- 1 запрос к базе данных для получения списка подписок.
- 1 запрос к Telegram API (`/sendMessage`) для отправки ответа.

### Получение справки или старт (`/help`, `/start`)
- 1 запрос к Telegram API (`/sendMessage`) для отправки сообщения.

### Автоматическое получение новостей (`CheckAndSendNews`)
- 1 запрос к базе данных для получения всех подписок.
- 1 запрос к News API для каждой категории (например, 2 категории).
- 1+ запросов к Telegram API (`/sendMessage`) для отправки новостей каждому пользователю (до 5 сообщений на категорию).

### Предположения о поведении пользователей
- Каждый из 10 000 пользователей в среднем:
  - Выполняет 1 подписку в день (`/add`).
  - Запрашивает новости 2 раза в день (`/news`).
  - Проверяет подписки 1 раз в день (`/mysubs`).
  - Использует `/start` или `/help` 0.5 раза в день.
  - Получает автоматические новости 12 раз в день (каждые 5 минут, 12 циклов `CheckAndSendNews`).
- Каждая команда `/news` или автоматическая отправка возвращает до 5 статей.
- Средний размер статьи: 1 КБ (JSON с заголовком, описанием, URL).

### Соотношение R/W нагрузки

#### Read (Чтение)
- **Telegram API**:
  - Получение обновлений (`/getUpdates` или вебхуки): ~10 000 пользователей × 5 команд/день = 50 000 запросов.
  - Все эндпоинты Telegram API для получения данных (например, `/getMe`) являются Read-операциями.
- **News API**:
  - Запросы к `/top-headlines` для `/news`: 10 000 × 2 запроса/день = 20 000 запросов.
  - Запросы для `CheckAndSendNews`: 2 категории × 12 циклов/день = 24 запроса.
- **Database (PostgreSQL)**:
  - Чтение подписок для `/mysubs`: 10 000 запросов/день.
  - Чтение всех подписок для `CheckAndSendNews`: 12 запросов/день.
  - Проверка подписки для `/news` (если есть): 20 000 запросов/день.

#### Write (Запись)
- **Telegram API**:
  - Отправка сообщений (`/sendMessage`):
    - Для `/add`: 10 000 сообщений/день.
    - Для `/news`: 10 000 × 2 запроса × 5 сообщений = 100 000 сообщений/день.
    - Для `/mysubs`: 10 000 сообщений/день.
    - Для `/start`/`/help`: 10 000 × 0.5 = 5 000 сообщений/день.
    - Для `CheckAndSendNews`: 10 000 пользователей × 2 категории × 5 сообщений × 12 циклов = 1 200 000 сообщений/день.
- **Database (PostgreSQL)**:
  - Сохранение подписки (`/add`): 10 000 записей/день.
  - Логирование взаимодействий (если реализовано): ~50 000 записей/день (по 5 команд/пользователь).
- **Временные файлы**:
  - Нет значительных операций записи на диск, так как бот не создает мультимедиа.

#### Вывод
- По количеству запросов: Read-запросы (~100 036) составляют ~30%, Write-запросы (~1 475 000) ~70%. Соотношение R/W ~ 1:14.
- По потреблению ресурсов: Write-запросы к Telegram API и News API более затратны из-за сетевых задержек и обработки Markdown. Соотношение R/W по ресурсам ~ 1:5.

### Объемы трафика

#### Внутренний трафик (между сервисами)
- **Telegram API**:
  - Входящие обновления (`/getUpdates`): JSON ~1 КБ/обновление. 50 000 обновлений × 1 КБ = 50 МБ/день.
  - Исходящие сообщения (`/sendMessage`): Текст ~500 байт/сообщение. 1 415 000 сообщений × 0.5 КБ = ~708 МБ/день.
- **News API**:
  - Запросы: ~200 байт/запрос. (20 000 + 24) × 0.2 КБ = ~4 МБ/день.
  - Ответы: 5 статей × 1 КБ/статья. (20 000 + 24) × 5 КБ = ~100 МБ/день.
- **Database**:
  - Запросы/ответы: ~100 байт/запрос. 90 012 запросов × 0.1 КБ = ~9 МБ/день.
- **Итого внутренний трафик**: ~50 + 708 + 4 + 100 + 9 = 871 МБ/день.

#### Внешний трафик (между ботом и Telegram)
- Входящий: 50 000 обновлений × 1 КБ = 50 МБ/день.
- Исходящий: 1 415 000 сообщений × 0.5 КБ = 708 МБ/день.
- **Итого внешний трафик**: 50 + 708 = 758 МБ/день.

### Объемы дисковой системы

#### База данных (PostgreSQL)
- **Таблицы**:
  - `users`: 10 000 пользователей × ~200 байт/запись = ~2 МБ.
  - `subscriptions`: 10 000 подписок × ~100 байт/запись = ~1 МБ/день. За 5 лет: 1 МБ × 365 × 5 = ~1.8 ГБ.
  - `articles`: 100 статей/день × 2 категории × ~1 КБ/статья = 200 КБ/день. За 5 лет: 200 КБ × 365 × 5 = ~365 МБ.
- **Индексы**: Примерно 50% от данных, ~1 ГБ за 5 лет.
- **Логирование (если реализовано)**: 50 000 взаимодействий/день × 100 байт = 5 МБ/день. За 5 лет: 5 МБ × 365 × 5 = ~9 ГБ.
- **Итого для БД**: ~2 МБ (users) + 1.8 ГБ (subscriptions) + 365 МБ (articles) + 1 ГБ (индексы) + 9 ГБ (логи) = ~12 ГБ за 5 лет.

#### Временные файлы
- Бот не создает мультимедиа, поэтому временные файлы минимальны.
- Возможны временные JSON-файлы для кэширования ответов News API: ~1 КБ/статья × 200 статей/день = 200 КБ/день.
- При 100 одновременных запросов: 100 × 200 КБ = 20 МБ временного пространства.
- Рекомендуется настроить автоматическую очистку (например, cron job) для удаления устаревших файлов.
- **Итого для временных файлов**: 20-50 МБ с учетом запаса и возможных сбоев.

#### Вывод
- **Соотношение R/W**:
  - По количеству запросов: ~1:14 (Write доминирует из-за отправки сообщений).
  - По ресурсам: ~1:5 (Write-запросы более затратны).
- **Трафик**:
  - Внутренний: ~871 МБ/день.
  - Внешний: ~758 МБ/день.
- **Диск**:
  - База данных: ~12 ГБ за 5 лет.
  - Временные файлы: 20-50 МБ с очисткой.

## Диаграммы C4 model

### Уровень 1: System Context Diagram
Эта диаграмма показывает, как система вписывается в окружающий мир.

| Элемент            | Описание                                                                 |
|--------------------|--------------------------------------------------------------------------|
| Пользователь       | Человек, использующий Telegram для взаимодействия с ботом.               |
| NewsBot            | Наш проект. Доставляет персонализированные новости по категориям.        |
| Telegram Bot API   | Внешний сервис, через который Telegram и наш бот обмениваются сообщениями.|
| News API           | Внешний сервис, источник новостей и метаданных (например, NewsAPI.org).   |

#### Описание взаимодействий
- Пользователь отправляет команды (`/start`, `/add`, `/news`, `/mysubs`, `/help`) через Telegram.
- Система NewsBot обрабатывает команды, запрашивает новости у News API и отправляет ответы через Telegram Bot API.
- News API предоставляет статьи по категориям (например, технологии, бизнес).

### Уровень 2: Container Diagram
Эта диаграмма показывает высокоуровневое устройство системы — её "контейнеры" (сервисы).

| Контейнер          | Описание                                                                 | Технология                          |
|--------------------|--------------------------------------------------------------------------|-------------------------------------|
| Telegram Bot Service| Принимает команды от пользователя, оркестрирует взаимодействие сервисов. | Go, github.com/skinass/telegram-bot-api/v5 |
| Database Service   | Хранит подписки пользователей и кэш новостей.                            | PostgreSQL                          |
| News API Client    | Интерфейс для получения новостей от внешнего News API.                  | Go, HTTP-клиент                    |

#### Описание взаимодействий
- **Telegram Bot Service**:
  - Получает команды от Telegram Bot API (через вебхуки или `/getUpdates`).
  - Записывает/читает подписки в Database Service.
  - Запрашивает новости у News API Client.
  - Отправляет сообщения пользователям через Telegram Bot API.
- **Database Service**:
  - Хранит таблицы `users`, `subscriptions`, `articles`.
  - Обслуживает запросы на чтение/запись от Telegram Bot Service.
- **News API Client**:
  - Отправляет HTTP-запросы к внешнему News API (например, `/top-headlines`).
  - Возвращает JSON с новостями в Telegram Bot Service.

### Контракты API
- **Telegram Bot API**:
  - `POST /bot<token>/sendMessage`: Отправка сообщения.
    - Параметры: `chat_id`, `text`, `parse_mode`.
    - Время отклика: <500 мс.
  - `POST /bot<token>/getUpdates`: Получение обновлений.
    - Время отклика: <1 с.
- **News API** (пример):
  - `GET /v2/top-headlines`: Получение новостей.
    - Параметры: `category`, `apiKey`.
    - Время отклика: <2 с.

### Нефункциональные требования
- Время отклика: 95% запросов <1 с.
- Доступность: 99.9%.
- Масштабируемость: Поддержка 100 000 пользователей.

## Схема базы данных

![ER Diagram](images/er_diagram.png)

Обоснование: Индексы на `user_id` и `category` обеспечивают быстрый доступ. PostgreSQL поддерживает высокую нагрузку с репликами.

## Схема масштабирования

### Схема масштабирования при росте нагрузки в 10 раз
При 10-кратном росте нагрузки (с 10 000 до 100 000 пользователей в сутки) текущая архитектура столкнется с ограничениями по производительности и отказоустойчивости. План масштабирования:

1. **База данных: Оптимизация PostgreSQL и репликация**
   - **Проблема**: Текущий экземпляр PostgreSQL может стать узким местом при 100 000 пользователей из-за высокой нагрузки на чтение (подписки, новости) и запись (новые подписки, логи).
   - **Решение**:
     - Настроить реплики PostgreSQL для операций чтения. Основная база (master) обрабатывает записи, а реплики — запросы на чтение (например, `/mysubs`, `CheckAndSendNews`).
     - Использовать индексы на таблицы `subscriptions` (`user_id`, `category`) и `articles` (`category`, `published_at`) для ускорения запросов.
     - Применить разделение (sharding) по `user_id`, если объем данных превысит возможности одной БД (маловероятно при 12 ГБ за 5 лет).
     - Настроить пулинг соединений (например, PgBouncer) для управления тысячами одновременных подключений от Telegram Bot Service.

2. **Кэширование: Введение Redis**
   - **Проблема**: Частые запросы к БД для чтения подписок и кэшированных новостей создают нагрузку. News API также имеет лимиты запросов (например, 1000/день для бесплатного плана NewsAPI.org).
   - **Решение**:
     - Использовать Redis как in-memory кэш для:
       - Подписок пользователей (`user_id` → список категорий, TTL 1 час).
       - Новостей по категориям (`category` → список статей, TTL 5 минут, синхронизировано с циклом `CheckAndSendNews`).
     - Telegram Bot Service сначала проверяет Redis, снижая нагрузку на PostgreSQL и News API.
     - Пример: Кэширование ответа `/news technology` сокращает запросы к News API на 80% при повторных вызовах.

3. **Масштабирование сервисов: Горизонтальное масштабирование и Load Balancer**
   - **Проблема**: Один экземпляр Telegram Bot Service не справится с 1 475 000 исходящих сообщений/день и ~500 000 обновлений от Telegram API.
   - **Решение**:
     - Запустить несколько экземпляров Telegram Bot Service (например, 5-10) в Docker-контейнерах.
     - Поставить Load Balancer (например, Nginx или Traefik) перед экземплярами для равномерного распределения входящих вебхуков от Telegram API.
     - Каждый экземпляр Telegram Bot Service является stateless, так как состояние хранится в Redis, а подписки — в PostgreSQL.

4. **Обработка автоматической отправки новостей: Асинхронная очередь задач**
   - **Проблема**: Метод `CheckAndSendNews` выполняет массовую отправку сообщений (до 1 200 000/день) синхронно, что может привести к перегрузке Telegram Bot Service и превышению лимитов Telegram API (30 сообщений/сек на чат).
   - **Решение**:
     - Использовать очередь задач (например, RabbitMQ или Kafka).
     - Telegram Bot Service в `CheckAndSendNews` создает задачи вида `{user_id, category, articles}` и помещает их в очередь.
     - Worker-сервисы (отдельные экземпляры Go-приложения) забирают задачи из очереди, форматируют сообщения и отправляют их через Telegram API с учетом лимитов.
     - После отправки воркер подтверждает выполнение задачи или уведомляет о сбое через другую очередь для повторной обработки.

5. **Хранение временных файлов: Объектное хранилище**
   - **Проблема**: Текущая реализация использует локальный диск для временных JSON-файлов (кэш News API, ~20-50 МБ). При нескольких экземплярах Telegram Bot Service файлы не синхронизируются, а сбои могут оставить "мусор".
   - **Решение**:
     - Использовать объектное хранилище (например, MinIO или Yandex Object Storage) для хранения временных файлов.
     - Telegram Bot Service загружает JSON-файлы в хранилище с уникальными ключами (`user_id:timestamp`).
     - Worker-сервисы скачивают файлы из хранилища при обработке задач.
     - Настроить автоматическую очистку (lifecycle policy) для удаления файлов старше 1 часа, минимизируя объем хранилища (~100 МБ даже при 100 000 пользователей).

6. **Мониторинг и отказоустойчивость**
   - **Проблема**: При 100 000 пользователей сбои в одном сервисе могут нарушить работу всей системы.
   - **Решение**:
     - Внедрить мониторинг с Prometheus и Grafana для отслеживания метрик (задержки Telegram API, использование CPU/RAM, длина очереди задач).
     - Использовать health checks в Docker для автоматического перезапуска упавших контейнеров.
     - Настроить алерты (например, через Alertmanager) для уведомлений о превышении лимитов или сбоях.

### Обновленная архитектура после масштабирования
- **Telegram Bot Service**: Несколько stateless экземпляров за Load Balancer, взаимодействуют с Redis, PostgreSQL, RabbitMQ.
- **PostgreSQL**: Master для записи, реплики для чтения, PgBouncer для пулинга.
- **Redis**: Кэш для подписок и новостей.
- **RabbitMQ**: Очередь для асинхронной отправки сообщений.
- **MinIO**: Объектное хранилище для временных файлов.
- **Prometheus/Grafana**: Мониторинг и алерты.

## Unit-тестирование

Проект включает комплексную систему unit-тестирования для основного сервиса Telegram Bot Service. Тесты написаны с использованием стандартного пакета `testing` в Go и библиотеки Testify для создания моков, обеспечивая высокое покрытие ключевой функциональности.

### Структура тестов
- **tgbot/test/internal/usecases/**:
  - `bot_usecase_test.go`: Тесты для методов обработки команд, форматирования новостей и логики автоматической отправки.
  - `mock_subscription_usecase.go`: Моки для интерфейса `SubscriptionUsecaseInterface`.
  - `mock_news_usecase.go`: Моки для интерфейса `NewsUsecaseInterface`.

### Основные возможности тестирования
- **Telegram Bot Service тесты**:
  - Моки для объектов Telegram Bot API (`tgbotapi.BotAPI`, `tgbotapi.Message`).
  - Тестирование обработчиков команд (`/start`, `/add`, `/news`, `/mysubs`, `/help`) в методе `HandleCommand`.
  - Проверка логики обработки неизвестных команд.
  - Тестирование метода `FormatArticle` для корректного форматирования новостей в Markdown.
  - Тестирование метода `CheckAndSendNews` для сценариев с новыми статьями и их отсутствием.
  - Моки для внешних зависимостей (`SubscriptionUsecase`, `NewsUsecase`) с использованием Testify.
  - Проверка краевых случаев (например, пустой список категорий, ошибки API).

### Запуск unit-тестов
```bash
# Запуск всех unit-тестов
make unit-test

# Прямо через Docker Compose
docker-compose run bot go test -v ./test/internal/usecases -run TestBotUsecase

# Локальный запуск
go test -v ./test/internal/usecases -run TestBotUsecase
```

### Конфигурация тестов
- Тесты используют стандартные возможности Go без дополнительных конфигурационных файлов.
- Моки генерируются с помощью Testify, обеспечивая изоляцию от внешних сервисов (Telegram API, News API, PostgreSQL).
- Тесты выполняются быстро, так как не требуют сетевых вызовов или работы с реальными файлами.

### Пример unit-теста
```go
func TestHandleCommand(t *testing.T) {
    mockSubUsecase := &MockSubscriptionUsecase{}
    mockNewsUsecase := &MockNewsUsecase{}
    bot, _ := tgbotapi.NewBotAPIWithClient("token", "endpoint", &http.Client{})
    usecase := NewBotUsecase(bot, mockSubUsecase, mockNewsUsecase, []string{"technology"})
    update := tgbotapi.Update{
        Message: &tgbotapi.Message{
            Chat: &tgbotapi.Chat{ID: 123},
            Text: "/start",
        },
    }
    usecase.HandleCommand(context.Background(), update)
    // Проверяем, что бот отправил правильное сообщение
    if len(bot.Messages) == 0 || bot.Messages[0].Text != "Здравствуйте! Данный бот предназначен для получения новостей..." {
        t.Errorf("Expected welcome message, got: %v", bot.Messages)
    }
}
```

## Интеграционное тестирование

Проект включает интеграционные тесты для проверки взаимодействия между Telegram Bot Service, Telegram API и внешними зависимостями, используя Telegram Dummy Server (TDS) для эмуляции Telegram API.

### Типы интеграционных тестов
- **Полный workflow тестирование**:
  - Тест полного цикла взаимодействия пользователя: подписка на категорию (`/add`), запрос новостей (`/news`), автоматическая отправка новостей (`CheckAndSendNews`).
  - Проверка взаимодействия Telegram Bot Service с TDS (эмуляция Telegram API).
  - Проверка обработки ошибок (например, неверная категория, сбои News API).
- **Database и News API интеграционные тесты**:
  - Тестирование реальных запросов к PostgreSQL (в тестовой БД через Docker).
  - Моки для News API для возврата предопределенных статей.
  - Валидация отправленных сообщений через TDS.

### Особенности интеграционных тестов
- Использование TDS для эмуляции Telegram API, что позволяет проверять реальную отправку сообщений без сетевых вызовов к Telegram.
- Тесты создают временную тестовую БД в Docker, минимизируя зависимости.
- Моки для `SubscriptionUsecase` и `NewsUsecase` позволяют изолировать внешние API.
- Тесты медленнее unit-тестов из-за запуска TDS и Docker, но обеспечивают проверку реального взаимодействия.

### Запуск интеграционных тестов
```bash
# Запуск всех интеграционных тестов
make integration-test

# Прямо через Docker Compose
docker-compose run bot go test -v ./test/internal/usecases -run TestBotCommands

# Локальный запуск
go test -v ./test/internal/usecases -run TestBotCommands
```

### Пример интеграционного теста
```go
func TestBotCommands(t *testing.T) {
    tds := NewTDS()
    ts := httptest.NewServer(tds)
    defer ts.Close()
    tgbotapi.APIEndpoint = ts.URL + "/bot%s/%s"
    bot, _ := tgbotapi.NewBotAPIWithClient("token", tgbotapi.APIEndpoint, &http.Client{})
    mockSubUsecase := &MockSubscriptionUsecase{}
    mockNewsUsecase := &MockNewsUsecase{}
    usecase := NewBotUsecase(bot, mockSubUsecase, mockNewsUsecase, []string{"technology"})
    mockSubUsecase.On("SaveSubscription", mock.Anything, mock.Anything, mock.Anything).Return(nil)
    err := SendMsgToBot(123, "/add technology")
    if err != nil {
        t.Fatalf("SendMsgToBot error: %v", err)
    }
    time.Sleep(50 * time.Millisecond)
    tds.Lock()
    if len(tds.Answers[123]) == 0 || tds.Answers[123][0] != "Вы успешно подписались на категорию 'technology'!" {
        t.Errorf("Expected subscription confirmation, got: %v", tds.Answers)
    }
    tds.Unlock()
}
```

## Сборка

- `Dockerfile`, `docker-compose.yml`, `Makefile` обеспечивают сборку, тестирование и запуск через:
  - `make build`
  - `make unit-test`
  - `make integration-test`
  - `make run`